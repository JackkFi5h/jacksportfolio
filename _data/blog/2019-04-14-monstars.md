---
template: BlogPost
path: /remark-kitchen-sink
date: 2020-07-14
title: 'Monstars'
thumbnail: /assets/monstarsThumbnail.png
metaDescription: 'test'
tags:
- C#
- Unity
---
#Monstars


Monstars is my most recent and most ambitious project that has been in full time development since **March 2019**. The inception of Monstars came as a result of my affinity towards the Pokémon franchise from an early age, playing the games on the Nintendo DS always made me wonder what a **3d realtime *Pokémon-like* multiplayer game** would look like. Monstars aims to recreate this childhood dream by being its own monster capturing game that encompasses realtime combat, multiplayer functionality (**100s of CCUs**) the aim of which is to train your monsters, explore the world with friends and battle to become a stronger trainer.

I attempted to make this game early in my programming career and had to quit due to a lack of knowledge. I devoted a further year into solidifying my knowledge in C# and unity by creating smaller games such as my Cube World clone to the point where I felt comfortable creating tackling this idea I've wanted to create for years.

After over a years development, Monstars is nearing the end of the main programming side of the development cycle with most features being partially to fully implemented with networking support with art being the limiting factor. Some of these features include;

- Catching a wide variety of monsters
- Training monsters by battling wild monsters
- Exploring, completing quests etc.
- Battling other playes, NPCs etc.
- Trading with other players
- Forming guilds and establishing in world guild houses with other players
- Creating structures (such as tents, cooking pots etc.)
- Battling other players, trading, forming guilds, as your monsters get stronger

#Multiplayer

Multiplayer has been the key focus during the development cycle of monstars as it is a game intended to be played with friends. Monstars is built off vis2k's "uSurvival" networking framework which is developed using the Mirror networking solution for Unity. This framework has been heavily altered to allow support for controllable monsters and everything that comes with that (state and unique stat synchronization, trading, guilds, pvp just to mention a few).  This has taught me a lot about networking in games, efficient networking principles and implementing client/server authentication to prevent exploitation of client side code.

#Realtime Combat
The combat in Monstars is by no means simplistic, I envisioned combat similar to that seen in both the Pokémon anime and the Pokken game series. This means the combat is real-time where the user has full control of their monsters movement and attacks. Users can dynamically block, counter, dash, perform combos to defeat their opponent. This presented a lot of challenges on both the programming and networking side.

#Finite State Machines
Although PVP combat is one of the main features of Monstars, users should also be able to fight and capture wild monsters, this required extensive research into how FSMs work as well as other solutions such as G.O.A.P where different actions are ranked by priority of which is best suited for a multitude of enemy/player relational and environmental variables. I implemented aspects of G.O.A.P in Monstars (i.e. enemy monster should run away if it is out of stamina, close to the player and has low health). This taught me a lot about FSMs and how they can be used to bring the AI to life.

The FSM manages states by first storing reference to what state the monster is in it does this using an **enum**. Enums allow easy synchronization over the network as they are only 1 byte. 

```csharp

public enum MonsterMoveState state : byte {
  IDLE,WALKING,RUNNING,JUMPING,STUNNED,DASHINGAIRBORNE,FAINTED,ATTACKING,DODGING,FLYING,FASTFLYING,DIGGING,
  BLOCKING,REFLECTING,RECOVERING,
}

```
---
This states value is constantly checked in unitys fixed update loop, if the monsters state changes, then the code executed as a result will change, some states require the variables inputDir and desiredGroundDir, these are Vectors that are updated each frame that detect what movement keys the user is imputting, and where the mosnter should move in relation to that and the ground.

```csharp

if (state == MonsterMoveState.IDLE) state = UpdateIDLE(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.WALKING) state = UpdateWALKINGandRUNNING(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.RUNNING) state = UpdateWALKINGandRUNNING(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.JUMPING) state = UpdateJUMPING(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.STUNNED) state = UpdateSTUNNED();
else if (state == MonsterMoveState.DASHING) state = UpdateDASHING();
else if (state == MonsterMoveState.AIRBORNE) state = UpdateAIRBORNE(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.DODGING) state = UpdateDODGING();
else if (state == MonsterMoveState.FLYING) state = UpdateFLYING(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.FASTFLYING) state = UpdateFLYING(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.DIGGING) state = UpdateDIGGING(inputDir, desiredGroundDir);
else if (state == MonsterMoveState.BLOCKING) state = UpdateBLOCKING();
else if (state == MonsterMoveState.ATTACKING) state = UpdateATTACKING(inputDir);
else if (state == MonsterMoveState.REFLECTING) state = UpdateREFLECTING();
else if (state == MonsterMoveState.RECOVERING) state = UpdateRECOVERING();
else if (state == MonsterMoveState.FAINTED) state = UpdateFAINTED();
else Debug.LogError
  ("Unhandled Movement State: " + state);
}
```
---
Now the corresponding `UpdateSTATENAME` method will be called, all of these methods follow the same deisgn pattern. We check for events we are interested in that would take us out of the current state, else we return the same state and the same update method will be called again next frame. 
```csharp
public MonsterMoveState UpdateATTACKING(Vector3 inputDir)
    {
        //variable attEndTime time is checked to see if the attack state should end (essentially the length of the attack animation)
        if (EventAttackTimeFinish())
            return MonsterMoveState.IDLE; //if so, return back to idle state
        else
        {
            //if we have been hit by the target and the move the target attacked us with is unblockable...
            if (EventHitByTarget() && EventTargetsAttackIsUnblockable())
                //then we invoke the OnStunned event, which has subscribers that do:
                //--Play a hit sound
                //--Display visual stun indicator on the UI
                //--increment the stunEndTime to the stunlength variable on the MonsterMoveData corresponding to the moveId recieved by the enemy 
                OnStunned?.Invoke(targetMoveId); 
                return MonsterMoveState.STUNNED; //return the stunned state
            return MonsterMoveState.ATTACKING; //else return attacking
        }
    }
```


